{
  "project": "eZunder",
  "description": "Revolutionary ePublishing client with JWT authentication and tiered subscriptions",
  "version": "1.0.0",
  "files": [
    {
      "name": "jwt",
      "content": "export interface JWTPayload {\n  sub: string; // User ID\n  email: string;\n  name: string;\n  role: UserRole;\n  iat: number; // Issued at\n  exp: number; // Expiration time\n  subscription?: {\n    tier: 'starter' | 'professional' | 'enterprise';\n    status: 'active' | 'canceled' | 'past_due' | 'incomplete';\n    expiresAt: number;\n  };\n}\n\nexport enum UserRole {\n  ADMIN = 'admin',\n  USER = 'user',\n  GUEST = 'guest'\n}\n\nexport interface TokenResponse {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n  user: User;\n}\n\nexport interface AuthCredentials {\n  email: string;\n  password: string;\n}\n\nexport interface RefreshTokenRequest {\n  refreshToken: string;\n}\n\nexport interface AuthError {\n  code: string;\n  message: string;\n  statusCode?: number;\n}\n\n// Enhanced User interface with JWT-specific fields\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  role: UserRole;\n  subscription?: UserSubscription;\n  createdAt: Date;\n  updatedAt: Date;\n  emailVerified: boolean;\n  lastLoginAt?: Date;\n}\n\nexport interface UserSubscription {\n  id: string;\n  tier: 'starter' | 'professional' | 'enterprise';\n  status: 'active' | 'canceled' | 'past_due' | 'incomplete';\n  currentPeriodStart: Date;\n  currentPeriodEnd: Date;\n  stripeSubscriptionId: string;\n  stripeCustomerId: string;\n}\n\n// Security-focused auth state\nexport interface AuthState {\n  user: User | null;\n  accessToken: string | null;\n  refreshToken: string | null;\n  isAuthenticated: boolean;\n  loading: boolean;\n  error: AuthError | null;\n  tokenExpiresAt: number | null;\n}",
      "suffix": "ts",
      "path": "types"
    },
    {
      "name": "authService",
      "content": "import axios, { AxiosInstance, AxiosResponse } from 'axios';\nimport { JWTPayload, TokenResponse, AuthCredentials, RefreshTokenRequest, AuthError } from '../types/jwt';\n\nclass AuthService {\n  private api: AxiosInstance;\n  private readonly TOKEN_KEY = 'eZunder_access_token';\n  private readonly REFRESH_TOKEN_KEY = 'eZunder_refresh_token';\n  private readonly TOKEN_EXPIRY_KEY = 'eZunder_token_expiry';\n  \n  constructor() {\n    this.api = axios.create({\n      baseURL: process.env.REACT_APP_API_BASE_URL,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    // Request interceptor to add auth token\n    this.api.interceptors.request.use(\n      (config) => {\n        const token = this.getAccessToken();\n        if (token && this.isTokenValid(token)) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n        return config;\n      },\n      (error) => Promise.reject(error)\n    );\n\n    // Response interceptor for token refresh\n    this.api.interceptors.response.use(\n      (response) => response,\n      async (error) => {\n        const originalRequest = error.config;\n        \n        if (error.response?.status === 401 && !originalRequest._retry) {\n          originalRequest._retry = true;\n          \n          try {\n            await this.refreshTokens();\n            const newToken = this.getAccessToken();\n            if (newToken) {\n              originalRequest.headers.Authorization = `Bearer ${newToken}`;\n              return this.api(originalRequest);\n            }\n          } catch (refreshError) {\n            this.clearTokens();\n            window.location.href = '/login';\n            return Promise.reject(refreshError);\n          }\n        }\n        \n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // Secure login with comprehensive error handling\n  async login(credentials: AuthCredentials): Promise<TokenResponse> {\n    try {\n      const response: AxiosResponse<TokenResponse> = await this.api.post('/auth/login', {\n        email: credentials.email.toLowerCase().trim(),\n        password: credentials.password,\n      });\n\n      const { accessToken, refreshToken, expiresIn, user } = response.data;\n      \n      // Validate token structure before storing\n      if (!this.isValidTokenStructure(accessToken)) {\n        throw new Error('Invalid token received from server');\n      }\n\n      this.storeTokens(accessToken, refreshToken, expiresIn);\n      return response.data;\n    } catch (error) {\n      throw this.handleAuthError(error);\n    }\n  }\n\n  // Secure registration\n  async register(userData: AuthCredentials & { name: string }): Promise<TokenResponse> {\n    try {\n      const response: AxiosResponse<TokenResponse> = await this.api.post('/auth/register', {\n        email: userData.email.toLowerCase().trim(),\n        password: userData.password,\n        name: userData.name.trim(),\n      });\n\n      const { accessToken, refreshToken, expiresIn } = response.data;\n      this.storeTokens(accessToken, refreshToken, expiresIn);\n      return response.data;\n    } catch (error) {\n      throw this.handleAuthError(error);\n    }\n  }\n\n  // Token refresh with retry logic\n  async refreshTokens(): Promise<TokenResponse> {\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    try {\n      const response: AxiosResponse<TokenResponse> = await this.api.post('/auth/refresh', {\n        refreshToken,\n      });\n\n      const { accessToken, refreshToken: newRefreshToken, expiresIn } = response.data;\n      this.storeTokens(accessToken, newRefreshToken, expiresIn);\n      return response.data;\n    } catch (error) {\n      this.clearTokens();\n      throw this.handleAuthError(error);\n    }\n  }\n\n  // Secure logout with server-side cleanup\n  async logout(): Promise<void> {\n    const refreshToken = this.getRefreshToken();\n    \n    try {\n      if (refreshToken) {\n        await this.api.post('/auth/logout', { refreshToken });\n      }\n    } catch (error) {\n      console.warn('Server logout failed:', error);\n    } finally {\n      this.clearTokens();\n    }\n  }\n\n  // Get current user with token validation\n  async getCurrentUser(): Promise<User> {\n    const token = this.getAccessToken();\n    if (!token || !this.isTokenValid(token)) {\n      throw new Error('No valid token available');\n    }\n\n    try {\n      const response: AxiosResponse<User> = await this.api.get('/auth/me');\n      return response.data;\n    } catch (error) {\n      throw this.handleAuthError(error);\n    }\n  }\n\n  // Token storage with security considerations\n  private storeTokens(accessToken: string, refreshToken: string, expiresIn: number): void {\n    const expiryTime = Date.now() + (expiresIn * 1000);\n    \n    // Use sessionStorage for access token (more secure)\n    sessionStorage.setItem(this.TOKEN_KEY, accessToken);\n    sessionStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString());\n    \n    // Use localStorage for refresh token (persists across sessions)\n    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\n  }\n\n  // Secure token retrieval\n  getAccessToken(): string | null {\n    const token = sessionStorage.getItem(this.TOKEN_KEY);\n    const expiry = sessionStorage.getItem(this.TOKEN_EXPIRY_KEY);\n    \n    if (!token || !expiry) return null;\n    \n    // Check if token is expired\n    if (Date.now() >= parseInt(expiry)) {\n      this.clearAccessToken();\n      return null;\n    }\n    \n    return token;\n  }\n\n  private getRefreshToken(): string | null {\n    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  // Token validation\n  private isTokenValid(token: string): boolean {\n    try {\n      const payload = this.decodeToken(token);\n      return payload.exp * 1000 > Date.now();\n    } catch {\n      return false;\n    }\n  }\n\n  private isValidTokenStructure(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n      \n      const payload = this.decodeToken(token);\n      return !!(payload.sub && payload.email && payload.exp);\n    } catch {\n      return false;\n    }\n  }\n\n  // JWT token decoding\n  decodeToken(token: string): JWTPayload {\n    try {\n      const base64Url = token.split('.')[1];\n      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n      const jsonPayload = decodeURIComponent(\n        window.atob(base64)\n          .split('')\n          .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n          .join('')\n      );\n      return JSON.parse(jsonPayload) as JWTPayload;\n    } catch (error) {\n      throw new Error('Invalid token format');\n    }\n  }\n\n  // Secure token cleanup\n  private clearTokens(): void {\n    sessionStorage.removeItem(this.TOKEN_KEY);\n    sessionStorage.removeItem(this.TOKEN_EXPIRY_KEY);\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  private clearAccessToken(): void {\n    sessionStorage.removeItem(this.TOKEN_KEY);\n    sessionStorage.removeItem(this.TOKEN_EXPIRY_KEY);\n  }\n\n  // Enhanced error handling\n  private handleAuthError(error: any): AuthError {\n    if (error.response?.data?.error) {\n      return {\n        code: error.response.data.code || 'AUTH_ERROR',\n        message: error.response.data.message || 'Authentication failed',\n        statusCode: error.response.status,\n      };\n    }\n\n    if (error.code === 'NETWORK_ERROR') {\n      return {\n        code: 'NETWORK_ERROR',\n        message: 'Network connection failed. Please check your internet connection.',\n      };\n    }\n\n    return {\n      code: 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n    };\n  }\n\n  // Check if user is authenticated\n  isAuthenticated(): boolean {\n    const token = this.getAccessToken();\n    return !!(token && this.isTokenValid(token));\n  }\n\n  // Get token expiry time\n  getTokenExpiryTime(): number | null {\n    const expiry = sessionStorage.getItem(this.TOKEN_EXPIRY_KEY);\n    return expiry ? parseInt(expiry) : null;\n  }\n}\n\n// Export singleton instance\nexport const authService = new AuthService();",
      "suffix": "ts",
      "path": "services"
    },
    {
      "name": "AuthContext",
      "content": "import React, { createContext, useContext, useReducer, useEffect, useCallback, ReactNode } from 'react';\nimport { authService } from '../services/authService';\nimport { User, AuthState, AuthCredentials, AuthError } from '../types/jwt';\n\ninterface AuthContextType {\n  state: AuthState;\n  login: (credentials: AuthCredentials) => Promise<void>;\n  register: (userData: AuthCredentials & { name: string }) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshUser: () => Promise<void>;\n  clearError: () => void;\n}\n\ntype AuthAction =\n  | { type: 'AUTH_START' }\n  | { type: 'AUTH_SUCCESS'; payload: { user: User; accessToken: string; refreshToken: string; expiresAt: number } }\n  | { type: 'AUTH_FAILURE'; payload: AuthError }\n  | { type: 'AUTH_LOGOUT' }\n  | { type: 'CLEAR_ERROR' }\n  | { type: 'UPDATE_USER'; payload: User }\n  | { type: 'TOKEN_REFRESH'; payload: { accessToken: string; expiresAt: number } };\n\nconst initialState: AuthState = {\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isAuthenticated: false,\n  loading: true,\n  error: null,\n  tokenExpiresAt: null,\n};\n\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'AUTH_START':\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        user: action.payload.user,\n        accessToken: action.payload.accessToken,\n        refreshToken: action.payload.refreshToken,\n        tokenExpiresAt: action.payload.expiresAt,\n        isAuthenticated: true,\n        loading: false,\n        error: null,\n      };\n\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        user: null,\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiresAt: null,\n        isAuthenticated: false,\n        loading: false,\n        error: action.payload,\n      };\n\n    case 'AUTH_LOGOUT':\n      return {\n        ...initialState,\n        loading: false,\n      };\n\n    case 'CLEAR_ERROR':\n      return {\n        ...state,\n        error: null,\n      };\n\n    case 'UPDATE_USER':\n      return {\n        ...state,\n        user: action.payload,\n      };\n\n    case 'TOKEN_REFRESH':\n      return {\n        ...state,\n        accessToken: action.payload.accessToken,\n        tokenExpiresAt: action.payload.expiresAt,\n      };\n\n    default:\n      return state;\n  }\n};\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // Initialize authentication state\n  const initializeAuth = useCallback(async () => {\n    dispatch({ type: 'AUTH_START' });\n\n    try {\n      const token = authService.getAccessToken();\n      const expiryTime = authService.getTokenExpiryTime();\n\n      if (token && expiryTime) {\n        // Fetch current user data\n        const user = await authService.getCurrentUser();\n        \n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user,\n            accessToken: token,\n            refreshToken: '', // Don't expose refresh token in state\n            expiresAt: expiryTime,\n          },\n        });\n      } else {\n        dispatch({ type: 'AUTH_LOGOUT' });\n      }\n    } catch (error) {\n      console.warn('Auth initialization failed:', error);\n      dispatch({ type: 'AUTH_LOGOUT' });\n    }\n  }, []);\n\n  // Login function with enhanced error handling\n  const login = useCallback(async (credentials: AuthCredentials) => {\n    dispatch({ type: 'AUTH_START' });\n\n    // Input validation\n    if (!credentials.email?.trim() || !credentials.password) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: {\n          code: 'INVALID_INPUT',\n          message: 'Email and password are required',\n        },\n      });\n      return;\n    }\n\n    try {\n      const response = await authService.login(credentials);\n      const expiryTime = authService.getTokenExpiryTime() || Date.now() + (3600 * 1000);\n\n      dispatch({\n        type: 'AUTH_SUCCESS',\n        payload: {\n          user: response.user,\n          accessToken: response.accessToken,\n          refreshToken: response.refreshToken,\n          expiresAt: expiryTime,\n        },\n      });\n    } catch (error) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: error as AuthError,\n      });\n    }\n  }, []);\n\n  // Register function\n  const register = useCallback(async (userData: AuthCredentials & { name: string }) => {\n    dispatch({ type: 'AUTH_START' });\n\n    // Input validation\n    if (!userData.email?.trim() || !userData.password || !userData.name?.trim()) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: {\n          code: 'INVALID_INPUT',\n          message: 'All fields are required',\n        },\n      });\n      return;\n    }\n\n    // Email format validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(userData.email)) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: {\n          code: 'INVALID_EMAIL',\n          message: 'Please enter a valid email address',\n        },\n      });\n      return;\n    }\n\n    // Password strength validation\n    if (userData.password.length < 8) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: {\n          code: 'WEAK_PASSWORD',\n          message: 'Password must be at least 8 characters long',\n        },\n      });\n      return;\n    }\n\n    try {\n      const response = await authService.register(userData);\n      const expiryTime = authService.getTokenExpiryTime() || Date.now() + (3600 * 1000);\n\n      dispatch({\n        type: 'AUTH_SUCCESS',\n        payload: {\n          user: response.user,\n          accessToken: response.accessToken,\n          refreshToken: response.refreshToken,\n          expiresAt: expiryTime,\n        },\n      });\n    } catch (error) {\n      dispatch({\n        type: 'AUTH_FAILURE',\n        payload: error as AuthError,\n      });\n    }\n  }, []);\n\n  // Logout function\n  const logout = useCallback(async () => {\n    try {\n      await authService.logout();\n    } catch (error) {\n      console.warn('Logout error:', error);\n    } finally {\n      dispatch({ type: 'AUTH_LOGOUT' });\n    }\n  }, []);\n\n  // Refresh user data\n  const refreshUser = useCallback(async () => {\n    if (!state.isAuthenticated) return;\n\n    try {\n      const user = await authService.getCurrentUser();\n      dispatch({ type: 'UPDATE_USER', payload: user });\n    } catch (error) {\n      console.warn('Failed to refresh user data:', error);\n    }\n  }, [state.isAuthenticated]);\n\n  // Clear error\n  const clearError = useCallback(() => {\n    dispatch({ type: 'CLEAR_ERROR' });\n  }, []);\n\n  // Token refresh timer\n  useEffect(() => {\n    if (!state.tokenExpiresAt || !state.isAuthenticated) return;\n\n    const timeToExpiry = state.tokenExpiresAt - Date.now();\n    const refreshTime = Math.max(timeToExpiry - (5 * 60 * 1000), 0); // Refresh 5 minutes before expiry\n\n    const timer = setTimeout(async () => {\n      try {\n        const response = await authService.refreshTokens();\n        const newExpiryTime = authService.getTokenExpiryTime() || Date.now() + (3600 * 1000);\n        \n        dispatch({\n          type: 'TOKEN_REFRESH',\n          payload: {\n            accessToken: response.accessToken,\n            expiresAt: newExpiryTime,\n          },\n        });\n      } catch (error) {\n        console.error('Token refresh failed:', error);\n        await logout();\n      }\n    }, refreshTime);\n\n    return () => clearTimeout(timer);\n  }, [state.tokenExpiresAt, state.isAuthenticated, logout]);\n\n  // Initialize auth on mount\n  useEffect(() => {\n    initializeAuth();\n  }, [initializeAuth]);\n\n  // Auto-logout on storage changes (multiple tabs)\n  useEffect(() => {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === 'eZunder_refresh_token' && !e.newValue && state.isAuthenticated) {\n        dispatch({ type: 'AUTH_LOGOUT' });\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, [state.isAuthenticated]);\n\n  const contextValue: AuthContextType = {\n    state,\n    login,\n    register,\n    logout,\n    refreshUser,\n    clearError,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook with error handling\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  \n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n};",
      "suffix": "tsx",
      "path": "contexts"
    },
    {
      "name": "ProtectedRoute",
      "content": "import React, { ReactNode, useEffect, useState } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../contexts/AuthContext';\nimport { useSubscription } from '../contexts/SubscriptionContext';\nimport { authService } from '../services/authService';\nimport { LoadingSpinner } from './LoadingSpinner';\nimport { UpgradePrompt } from './UpgradePrompt';\nimport { ErrorBoundary } from './ErrorBoundary';\n\ninterface ProtectedRouteProps {\n  children: ReactNode;\n  requireSubscription?: boolean;\n  requiredTier?: 'starter' | 'professional' | 'enterprise';\n  requiredFeature?: string;\n  fallback?: ReactNode;\n  roles?: Array<'admin' | 'user' | 'guest'>;\n}\n\nexport const ProtectedRoute: React.FC<ProtectedRouteProps> = ({\n  children,\n  requireSubscription = false,\n  requiredTier,\n  requiredFeature,\n  fallback,\n  roles = ['user', 'admin'],\n}) => {\n  const { state: authState } = useAuth();\n  const { state: subscriptionState, hasFeature } = useSubscription();\n  const location = useLocation();\n  const [tokenValidated, setTokenValidated] = useState(false);\n\n  // Validate token integrity on mount\n  useEffect(() => {\n    const validateToken = async () => {\n      try {\n        if (authState.accessToken) {\n          const isValid = authService.isAuthenticated();\n          if (!isValid && authState.isAuthenticated) {\n            // Token is invalid but auth state thinks we're authenticated\n            console.warn('Token validation failed, logging out');\n            await authService.logout();\n          }\n        }\n      } catch (error) {\n        console.error('Token validation error:', error);\n      } finally {\n        setTokenValidated(true);\n      }\n    };\n\n    validateToken();\n  }, [authState.accessToken, authState.isAuthenticated]);\n\n  // Show loading while authentication is being determined\n  if (authState.loading || subscriptionState.loading || !tokenValidated) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <LoadingSpinner size=\"large\" />\n      </div>\n    );\n  }\n\n  // Redirect to login if not authenticated\n  if (!authState.isAuthenticated || !authState.user) {\n    return (\n      <Navigate \n        to=\"/login\" \n        state={{ \n          from: location.pathname + location.search,\n          message: 'Please log in to access this page'\n        }} \n        replace \n      />\n    );\n  }\n\n  // Check role-based access\n  if (roles && roles.length > 0 && !roles.includes(authState.user.role)) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-center p-8\">\n          <h2 className=\"text-2xl font-bold text-red-600 mb-4\">Access Denied</h2>\n          <p className=\"text-gray-600\">You don't have permission to access this page.</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Check subscription requirements\n  if (requireSubscription && !subscriptionState.subscription) {\n    return fallback || <Navigate to=\"/subscription/plans\" replace />;\n  }\n\n  // Check tier requirements with hierarchy validation\n  if (requiredTier && subscriptionState.subscription) {\n    const tierHierarchy = { starter: 1, professional: 2, enterprise: 3 };\n    const userTierLevel = tierHierarchy[subscriptionState.subscription.tier];\n    const requiredTierLevel = tierHierarchy[requiredTier];\n\n    if (userTierLevel < requiredTierLevel) {\n      return fallback || <UpgradePrompt requiredTier={requiredTier} />;\n    }\n  }\n\n  // Check subscription status (must be active for paid features)\n  if (requireSubscription && subscriptionState.subscription?.status !== 'active') {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-center p-8\">\n          <h2 className=\"text-2xl font-bold text-yellow-600 mb-4\">Subscription Required</h2>\n          <p className=\"text-gray-600 mb-4\">\n            Your subscription is {subscriptionState.subscription?.status || 'inactive'}. \n            Please update your subscription to continue.\n          </p>\n          <button \n            onClick={() => window.location.href = '/subscription/plans'}\n            className=\"bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700\"\n          >\n            Update Subscription\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // Check feature requirements\n  if (requiredFeature && !hasFeature(requiredFeature as any)) {\n    return fallback || <UpgradePrompt feature={requiredFeature} />;\n  }\n\n  // Wrap children in error boundary for additional security\n  return (\n    <ErrorBoundary>\n      {children}\n    </ErrorBoundary>\n  );\n};\n\n// Higher-order component for role-based access\nexport const withRoleProtection = <P extends object>(\n  Component: React.ComponentType<P>,\n  requiredRoles: Array<'admin' | 'user' | 'guest'>\n) => {\n  return (props: P) => (\n    <ProtectedRoute roles={requiredRoles}>\n      <Component {...props} />\n    </ProtectedRoute>\n  );\n};\n\n// Feature gate component with enhanced security\ninterface FeatureGateProps {\n  feature: string;\n  tier?: 'starter' | 'professional' | 'enterprise';\n  roles?: Array<'admin' | 'user' | 'guest'>;\n  children: ReactNode;\n  fallback?: ReactNode;\n  showUpgrade?: boolean;\n}\n\nexport const FeatureGate: React.FC<FeatureGateProps> = ({\n  feature,\n  tier,\n  roles,\n  children,\n  fallback,\n  showUpgrade = true,\n}) => {\n  const { state: authState } = useAuth();\n  const { hasFeature, state: subscriptionState } = useSubscription();\n\n  // Check authentication\n  if (!authState.isAuthenticated || !authState.user) {\n    return <>{fallback}</>;\n  }\n\n  // Check role requirements\n  if (roles && roles.length > 0 && !roles.includes(authState.user.role)) {\n    return <>{fallback}</>;\n  }\n\n  // Check tier requirements\n  if (tier && subscriptionState.subscription) {\n    const tierHierarchy = { starter: 1, professional: 2, enterprise: 3 };\n    const userTierLevel = tierHierarchy[subscriptionState.subscription.tier];\n    const requiredTierLevel = tierHierarchy[tier];\n\n    if (userTierLevel < requiredTierLevel) {\n      return showUpgrade ? <UpgradePrompt requiredTier={tier} /> : <>{fallback}</>;\n    }\n  }\n\n  // Check feature access\n  if (!hasFeature(feature as any)) {\n    return showUpgrade ? <UpgradePrompt feature={feature} /> : <>{fallback}</>;\n  }\n\n  return <>{children}</>;\n};\n\n// Admin-only component wrapper\nexport const AdminOnly: React.FC<{ children: ReactNode; fallback?: ReactNode }> = ({\n  children,\n  fallback,\n}) => {\n  return (\n    <FeatureGate \n      feature=\"admin_access\" \n      roles={['admin']} \n      fallback={fallback}\n      showUpgrade={false}\n    >\n      {children}\n    </FeatureGate>\n  );\n};",
      "suffix": "tsx",
      "path": "components"
    },
    {
      "name": "api",
      "content": "import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { authService } from './authService';\nimport { User, UserSubscription } from '../types/jwt';\n\ninterface ApiResponse<T = any> {\n  data: T;\n  message?: string;\n  status: 'success' | 'error';\n}\n\ninterface PaginatedResponse<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n  };\n}\n\nclass ApiService {\n  private api: AxiosInstance;\n  private readonly baseURL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';\n\n  constructor() {\n    this.api = axios.create({\n      baseURL: this.baseURL,\n      timeout: 15000,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor with token management\n    this.api.interceptors.request.use(\n      (config) => {\n        const token = authService.getAccessToken();\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n\n        // Add request timestamp for debugging\n        config.metadata = { startTime: Date.now() };\n        \n        return config;\n      },\n      (error) => {\n        console.error('Request interceptor error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Response interceptor with enhanced error handling\n    this.api.interceptors.response.use(\n      (response) => {\n        // Log request duration in development\n        if (process.env.NODE_ENV === 'development' && response.config.metadata) {\n          const duration = Date.now() - response.config.metadata.startTime;\n          console.log(`API Request: ${response.config.method?.toUpperCase()} ${response.config.url} - ${duration}ms`);\n        }\n\n        return response;\n      },\n      async (error) => {\n        const originalRequest = error.config;\n\n        // Handle network errors\n        if (!error.response) {\n          throw new Error('Network error: Please check your internet connection');\n        }\n\n        // Handle 401 unauthorized errors\n        if (error.response.status === 401 && !originalRequest._retry) {\n          originalRequest._retry = true;\n\n          try {\n            await authService.refreshTokens();\n            const newToken = authService.getAccessToken();\n            if (newToken) {\n              originalRequest.headers.Authorization = `Bearer ${newToken}`;\n              return this.api(originalRequest);\n            }\n          } catch (refreshError) {\n            authService.logout();\n            window.location.href = '/login';\n          }\n        }\n\n        // Handle other HTTP errors\n        const errorMessage = error.response?.data?.message || error.message || 'An unexpected error occurred';\n        throw new Error(errorMessage);\n      }\n    );\n  }\n\n  // Generic request method with type safety\n  private async request<T>(config: AxiosRequestConfig): Promise<T> {\n    try {\n      const response: AxiosResponse<ApiResponse<T>> = await this.api(config);\n      return response.data.data;\n    } catch (error) {\n      console.error('API request failed:', error);\n      throw error;\n    }\n  }\n\n  // User management methods\n  async getUser(userId: string): Promise<User> {\n    return this.request<User>({\n      method: 'GET',\n      url: `/users/${userId}`,\n    });\n  }\n\n  async updateUser(userId: string, userData: Partial<User>): Promise<User> {\n    return this.request<User>({\n      method: 'PATCH',\n      url: `/users/${userId}`,\n      data: userData,\n    });\n  }\n\n  async deleteUser(userId: string): Promise<void> {\n    await this.request<void>({\n      method: 'DELETE',\n      url: `/users/${userId}`,\n    });\n  }\n\n  // Subscription management methods\n  async getSubscription(userId: string): Promise<UserSubscription | null> {\n    try {\n      return await this.request<UserSubscription>({\n        method: 'GET',\n        url: `/users/${userId}/subscription`,\n      });\n    } catch (error) {\n      // Return null if no subscription found\n      if (error instanceof Error && error.message.includes('404')) {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  async updateUserSubscription(subscriptionData: Partial<UserSubscription>): Promise<UserSubscription> {\n    return this.request<UserSubscription>({\n      method: 'POST',\n      url: '/subscriptions/update',\n      data: subscriptionData,\n    });\n  }\n\n  async cancelSubscription(stripeSubscriptionId: string): Promise<void> {\n    await this.request<void>({\n      method: 'POST',\n      url: '/subscriptions/cancel',\n      data: { stripeSubscriptionId },\n    });\n  }\n\n  // Stripe integration methods\n  async createCheckoutSession(data: {\n    priceId: string;\n    userId: string;\n    successUrl: string;\n    cancelUrl: string;\n  }): Promise<{ sessionId: string }> {\n    return this.request<{ sessionId: string }>({\n      method: 'POST',\n      url: '/stripe/create-checkout-session',\n      data,\n    });\n  }\n\n  async createPortalSession(data: {\n    customerId: string;\n    returnUrl: string;\n  }): Promise<{ url: string }> {\n    return this.request<{ url: string }>({\n      method: 'POST',\n      url: '/stripe/create-portal-session',\n      data,\n    });\n  }\n\n  // Publication management methods (example)\n  async getPublications(userId: string, page = 1, limit = 10): Promise<PaginatedResponse<any>> {\n    return this.request<PaginatedResponse<any>>({\n      method: 'GET',\n      url: `/users/${userId}/publications`,\n      params: { page, limit },\n    });\n  }\n\n  async createPublication(publicationData: any): Promise<any> {\n    return this.request<any>({\n      method: 'POST',\n      url: '/publications',\n      data: publicationData,\n    });\n  }\n\n  async updatePublication(publicationId: string, publicationData: any): Promise<any> {\n    return this.request<any>({\n      method: 'PATCH',\n      url: `/publications/${publicationId}`,\n      data: publicationData,\n    });\n  }\n\n  async deletePublication(publicationId: string): Promise<void> {\n    await this.request<void>({\n      method: 'DELETE',\n      url: `/publications/${publicationId}`,\n    });\n  }\n\n  // Analytics methods (for different tiers)\n  async getAnalytics(userId: string, tier: 'basic' | 'advanced' | 'full'): Promise<any> {\n    return this.request<any>({\n      method: 'GET',\n      url: `/analytics/${userId}`,\n      params: { tier },\n    });\n  }\n\n  // Health check method\n  async healthCheck(): Promise<{ status: string; timestamp: string }> {\n    return this.request<{ status: string; timestamp: string }>({\n      method: 'GET',\n      url: '/health',\n    });\n  }\n}\n\n// Export singleton instance\nexport const ApiService = new ApiService();\n\n// Declare module augmentation for axios\ndeclare module 'axios' {\n  interface AxiosRequestConfig {\n    metadata?: {\n      startTime: number;\n    };\n  }\n}",
      "suffix": "ts",
      "path": "services"
    },
    {
      "name": "ErrorBoundary",
      "content": "import React, { Component, ErrorInfo, ReactNode } from 'react';\nimport { authService } from '../services/authService';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  public state: State = {\n    hasError: false,\n    error: null,\n    errorInfo: null,\n  };\n\n  public static getDerivedStateFromError(error: Error): State {\n    return {\n      hasError: true,\n      error,\n      errorInfo: null,\n    };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('ErrorBoundary caught an error:', error, errorInfo);\n    \n    this.setState({\n      error,\n      errorInfo,\n    });\n\n    // Log error to monitoring service\n    this.logErrorToService(error, errorInfo);\n\n    // Check if error is auth-related and handle logout\n    if (this.isAuthError(error)) {\n      authService.logout();\n      window.location.href = '/login';\n    }\n  }\n\n  private isAuthError(error: Error): boolean {\n    const authErrorPatterns = [\n      'authentication',\n      'unauthorized',\n      'token',\n      'jwt',\n      'session',\n      'login',\n    ];\n\n    const errorMessage = error.message.toLowerCase();\n    return authErrorPatterns.some(pattern => errorMessage.includes(pattern));\n  }\n\n  private logErrorToService(error: Error, errorInfo: ErrorInfo): void {\n    // In production, send to error monitoring service\n    if (process.env.NODE_ENV === 'production') {\n      // Example: Send to Sentry, LogRocket, etc.\n      console.error('Production error logged:', {\n        error: error.message,\n        stack: error.stack,\n        componentStack: errorInfo.componentStack,\n        timestamp: new Date().toISOString(),\n        userId: authService.isAuthenticated() ? 'authenticated' : 'anonymous',\n      });\n    }\n  }\n\n  private handleRetry = () => {\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n    });\n  };\n\n  public render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"min-h-screen flex items-center justify-center bg-gray-50\">\n          <div className=\"max-w-md w-full bg-white shadow-lg rounded-lg p-6\">\n            <div className=\"flex items-center justify-center w-12 h-12 mx-auto bg-red-100 rounded-full mb-4\">\n              <svg className=\"w-6 h-6 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z\" />\n              </svg>\n            </div>\n            \n            <h1 className=\"text-xl font-semibold text-gray-900 text-center mb-2\">\n              Something went wrong\n            </h1>\n            \n            <p className=\"text-gray-600 text-center mb-6\">\n              We're sorry, but something unexpected happened. Please try again.\n            </p>\n\n            {process.env.NODE_ENV === 'development' && (\n              <details className=\"mb-4 p-4 bg-gray-100 rounded text-sm\">\n                <summary className=\"cursor-pointer font-medium\">Error Details</summary>\n                <pre className=\"mt-2 text-xs overflow-auto\">\n                  {this.state.error && this.state.error.toString()}\n                  <br />\n                  {this.state.errorInfo.componentStack}\n                </pre>\n              </details>\n            )}\n\n            <div className=\"flex gap-3\">\n              <button\n                onClick={this.handleRetry}\n                className=\"flex-1 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors\"\n              >\n                Try Again\n              </button>\n              \n              <button\n                onClick={() => window.location.href = '/'}\n                className=\"flex-1 bg-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-400 transition-colors\"\n              >\n                Go Home\n              </button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}",
      "suffix": "tsx",
      "path": "components"
    },
    {
      "name": "LoadingSpinner",
      "content": "import React from 'react';\n\ninterface LoadingSpinnerProps {\n  size?: 'small' | 'medium' | 'large';\n  className?: string;\n}\n\nexport const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ \n  size = 'medium', \n  className = '' \n}) => {\n  const sizeClasses = {\n    small: 'w-4 h-4',\n    medium: 'w-8 h-8',\n    large: 'w-12 h-12',\n  };\n\n  return (\n    <div className={`flex items-center justify-center ${className}`}>\n      <div \n        className={`${sizeClasses[size]} border-2 border-gray-200 border-t-blue-600 rounded-full animate-spin`}\n      />\n    </div>\n  );\n};",
      "suffix": "tsx",
      "path": "components"
    },
    {
      "name": "App",
      "content": "import React from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { AuthProvider } from './contexts/AuthContext';\nimport { SubscriptionProvider } from './contexts/SubscriptionContext';\nimport { ProtectedRoute, FeatureGate, AdminOnly } from './components/ProtectedRoute';\nimport { ErrorBoundary } from './components/ErrorBoundary';\nimport { LoadingSpinner } from './components/LoadingSpinner';\n\n// Page imports\nimport { LoginPage } from './pages/LoginPage';\nimport { RegisterPage } from './pages/RegisterPage';\nimport { DashboardPage } from './pages/DashboardPage';\nimport { SubscriptionPlansPage } from './pages/SubscriptionPlansPage';\nimport { SettingsPage } from './pages/SettingsPage';\nimport { PublicationsPage } from './pages/PublicationsPage';\nimport { AnalyticsPage } from './pages/AnalyticsPage';\nimport { ApiKeysPage } from './pages/ApiKeysPage';\nimport { AdminPanelPage } from './pages/AdminPanelPage';\nimport { NotFoundPage } from './pages/NotFoundPage';\n\nconst App: React.FC = () => {\n  return (\n    <ErrorBoundary>\n      <AuthProvider>\n        <SubscriptionProvider>\n          <Router>\n            <div className=\"min-h-screen bg-gray-50\">\n              <Routes>\n                {/* Public routes */}\n                <Route path=\"/login\" element={<LoginPage />} />\n                <Route path=\"/register\" element={<RegisterPage />} />\n                \n                {/* Protected routes */}\n                <Route path=\"/dashboard\" element={\n                  <ProtectedRoute requireSubscription>\n                    <DashboardPage />\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/publications\" element={\n                  <ProtectedRoute requireSubscription>\n                    <PublicationsPage />\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/publications/new\" element={\n                  <ProtectedRoute requireSubscription>\n                    <FeatureGate feature=\"canCreatePublication\">\n                      <CreatePublicationPage />\n                    </FeatureGate>\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/analytics\" element={\n                  <ProtectedRoute requiredTier=\"professional\">\n                    <AnalyticsPage />\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/api-keys\" element={\n                  <ProtectedRoute requiredTier=\"enterprise\">\n                    <ApiKeysPage />\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/settings/*\" element={\n                  <ProtectedRoute requireSubscription>\n                    <SettingsPage />\n                  </ProtectedRoute>\n                } />\n                \n                <Route path=\"/subscription/plans\" element={\n                  <ProtectedRoute>\n                    <SubscriptionPlansPage />\n                  </ProtectedRoute>\n                } />\n                \n                {/* Admin routes */}\n                <Route path=\"/admin/*\" element={\n                  <AdminOnly>\n                    <AdminPanelPage />\n                  </AdminOnly>\n                } />\n                \n                {/* Redirects */}\n                <Route path=\"/\" element={<Navigate to=\"/dashboard\" replace />} />\n                <Route path=\"*\" element={<NotFoundPage />} />\n              </Routes>\n            </div>\n          </Router>\n        </SubscriptionProvider>\n      </AuthProvider>\n    </ErrorBoundary>\n  );\n};\n\nexport default App;",
      "suffix": "tsx",
      "path": ""
    },
    {
      "name": "SubscriptionContext",
      "content": "import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { useAuth } from '../hooks/useAuth';\nimport { UserSubscription } from '../types/auth';\nimport { ApiService } from '../services/api';\n\ninterface SubscriptionState {\n  subscription: UserSubscription | null;\n  loading: boolean;\n  error: string | null;\n  features: SubscriptionFeatures;\n}\n\ninterface SubscriptionFeatures {\n  maxPublications: number;\n  customBranding: boolean;\n  prioritySupport: boolean;\n  apiAccess: boolean;\n  whiteLabel: boolean;\n  analytics: 'basic' | 'advanced' | 'full';\n}\n\ntype SubscriptionAction =\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'SET_SUBSCRIPTION'; payload: UserSubscription | null }\n  | { type: 'SET_ERROR'; payload: string | null }\n  | { type: 'UPDATE_SUBSCRIPTION'; payload: Partial<UserSubscription> };\n\nconst subscriptionReducer = (\n  state: SubscriptionState,\n  action: SubscriptionAction\n): SubscriptionState => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    case 'SET_SUBSCRIPTION':\n      return {\n        ...state,\n        subscription: action.payload,\n        features: getFeaturesByTier(action.payload?.tier || null),\n        loading: false,\n        error: null\n      };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload, loading: false };\n    case 'UPDATE_SUBSCRIPTION':\n      if (!state.subscription) return state;\n      const updatedSubscription = { ...state.subscription, ...action.payload };\n      return {\n        ...state,\n        subscription: updatedSubscription,\n        features: getFeaturesByTier(updatedSubscription.tier)\n      };\n    default:\n      return state;\n  }\n};\n\nconst getFeaturesByTier = (tier: string | null): SubscriptionFeatures => {\n  switch (tier) {\n    case 'starter':\n      return {\n        maxPublications: 5,\n        customBranding: false,\n        prioritySupport: false,\n        apiAccess: false,\n        whiteLabel: false,\n        analytics: 'basic'\n      };\n    case 'professional':\n      return {\n        maxPublications: 25,\n        customBranding: true,\n        prioritySupport: true,\n        apiAccess: false,\n        whiteLabel: false,\n        analytics: 'advanced'\n      };\n    case 'enterprise':\n      return {\n        maxPublications: Infinity,\n        customBranding: true,\n        prioritySupport: true,\n        apiAccess: true,\n        whiteLabel: true,\n        analytics: 'full'\n      };\n    default:\n      return {\n        maxPublications: 0,\n        customBranding: false,\n        prioritySupport: false,\n        apiAccess: false,\n        whiteLabel: false,\n        analytics: 'basic'\n      };\n  }\n};\n\nconst SubscriptionContext = createContext<{\n  state: SubscriptionState;\n  dispatch: React.Dispatch<SubscriptionAction>;\n  refreshSubscription: () => Promise<void>;\n  hasFeature: (feature: keyof SubscriptionFeatures) => boolean;\n  canCreatePublication: () => boolean;\n} | null>(null);\n\nexport const SubscriptionProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const { user, isAuthenticated } = useAuth();\n  const [state, dispatch] = useReducer(subscriptionReducer, {\n    subscription: user?.subscription || null,\n    loading: false,\n    error: null,\n    features: getFeaturesByTier(user?.subscription?.tier || null)\n  });\n\n  const refreshSubscription = async () => {\n    if (!isAuthenticated || !user) return;\n\n    dispatch({ type: 'SET_LOADING', payload: true });\n    try {\n      const subscription = await ApiService.getSubscription(user.id);\n      dispatch({ type: 'SET_SUBSCRIPTION', payload: subscription });\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to fetch subscription' });\n    }\n  };\n\n  const hasFeature = (feature: keyof SubscriptionFeatures): boolean => {\n    return !!state.features[feature];\n  };\n\n  const canCreatePublication = (): boolean => {\n    // This would integrate with your publication count logic\n    const currentPublications = 0; // Fetch from your state/API\n    return currentPublications < state.features.maxPublications;\n  };\n\n  useEffect(() => {\n    if (user?.subscription) {\n      dispatch({ type: 'SET_SUBSCRIPTION', payload: user.subscription });\n    }\n  }, [user]);\n\n  return (\n    <SubscriptionContext.Provider value={{\n      state,\n      dispatch,\n      refreshSubscription,\n      hasFeature,\n      canCreatePublication\n    }}>\n      {children}\n    </SubscriptionContext.Provider>\n  );\n};\n\nexport const useSubscription = () => {\n  const context = useContext(SubscriptionContext);\n  if (!context) {\n    throw new Error('useSubscription must be used within a SubscriptionProvider');\n  }\n  return context;\n};",
      "suffix": "tsx",
      "path": "contexts"
    }
  ]
}
